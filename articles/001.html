<!DOCTYPE html><html data-bs-theme="light" style="cursor: none;"><head><meta charset="utf-8">
<meta name="theme-color" content="#ffffff">
<meta name="description" content="Huzaifa Yasin is a full-stack web developer from Lahore, Pakistan, specializing in Python, javascript, webdevelopment and Cloud.">
<script type='text/javascript'>
  window.smartlook||(function(d) {
    var o=smartlook=function(){ o.api.push(arguments)},h=d.getElementsByTagName('head')[0];
    var c=d.createElement('script');o.api=new Array();c.async=true;c.type='text/javascript';
    c.charset='utf-8';c.src='https://web-sdk.smartlook.com/recorder.js';h.appendChild(c);
    })(document);
    smartlook('init', '471490b13c6da3e0edce13748ce7608d9571413b', { region: 'eu' });
</script><meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no"><title>Huzaifa Yasin | Portfolio</title><meta property="og:type" content="website"><meta name="" content=""><meta name="twitter:card" content="summary_large_image"><link rel="icon" type="image/jpeg" sizes="1484x1484" href="../assets/img/Me%20(1).jpg"><link rel="stylesheet" href="../assets/bootstrap/css/bootstrap.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,400i,700,700i,600,600i&amp;display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Alata&amp;display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Anton&amp;display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Antonio&amp;display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Archivo+Black&amp;display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Bahiana&amp;display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Bayon&amp;display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Bebas+Neue&amp;display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&amp;display=swap"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../assets/css/styles.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/baguettebox.js/1.10.0/baguetteBox.min.css"></head><body><div class="rQaaEmN7ffY"><h2 class="w-50 navbar-simple-l" data-target="home"><a href="../index.html"><strong>HUZAIFA</strong></a></h2><div class="w-50 gkjghw"><a role="button" class="navbar-simple-l C3ha" data-bs-toggle="offcanvas" href="#offcanvas"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 16 16" class="bi bi-asterisk">
  <path d="M8 0a1 1 0 0 1 1 1v5.268l4.562-2.634a1 1 0 1 1 1 1.732L10 8l4.562 2.634a1 1 0 1 1-1 1.732L9 9.732V15a1 1 0 1 1-2 0V9.732l-4.562 2.634a1 1 0 1 1-1-1.732L6 8 1.438 5.366a1 1 0 0 1 1-1.732L7 6.268V1a1 1 0 0 1 1-1z"></path>
</svg></a><a role="button" class="navbar-simple-l p2hL" data-bs-toggle="offcanvas" href="#offcanvas">MENU</a></div></div><div class="d-flex" style="height: 75px;"></div><div class="curor-custom"><div class="cursor-dot-outline"></div><div class="cursor-dot"></div></div><section><div class="d-center-top"><div class="qVXI3bDF1 cRLdTu"><h1>Deploying Lambda Functions with Binaries: LaTeX Compilation Implementation</h1></div></div><div class="P3Euu9"><p>18 November 2024</p></div><div class="min-vh-100 d-center-top"><div class="qVXI3bDF"><p><br>Imagine needing to generate professional-grade PDFs, process files, or run complex scripts in a serverless environment. AWS Lambda’s serverless model eliminates the hassle of managing infrastructure, but it comes with its own set of limitations—particularly when your application requires access to advanced software like LaTeX. The default Lambda runtime is lightweight and lacks the tools and binaries needed for such operations, which makes deploying these applications a significant challenge.<br><br>For applications requiring binaries or software exceeding the 50 MB deployment package size limit, a different approach is needed. In this guide, we'll tackle this problem by exploring how to deploy a LaTeX-powered Lambda function using a containerized custom runtime. By packaging all necessary dependencies into a Docker image, we can overcome Lambda's runtime restrictions while ensuring our function remains scalable and easy to deploy.<br><br>I'll walk you through the step-by-step process of creating a Docker-based deployment pipeline, enabling your Lambda function to seamlessly generate PDF documents using LaTeX. Whether you're building a document generation service, report creation system, or any other application requiring binary dependencies, this guide will help you navigate the complexities of deploying Lambda functions with custom runtime requirements.</p><p id="note"><strong>Note:</strong> <em>Writing Python scripts to compile LaTeX files is beyond the scope of this discussion.&nbsp;For simplicity, this guide assumes you have a Python script that processes LaTeX documents and generates PDFs. However,&nbsp;If you're just starting, you can use Python's built-in subprocess module to invoke a TeX compiler for generating PDFs from LaTeX sources.</em></p><h3>The Challenge of Deploying Binaries to Lambda</h3><p><br>AWS Lambda functions operate within a carefully controlled environment designed for simplicity and security. While this design philosophy works well for many applications, it introduces several significant limitations:</p><ol><li><strong>Deployment Package Size:</strong><ul class="nomarginplainli"><li>ZIP deployment packages are limited to 50 MB compressed</li><li>Layer size restrictions of 250 MB uncompressed</li><li>Combined package and layer limit of 250 MB</li></ul></li><li><strong>Package Management:</strong><ul class="nomarginplainli"><li>Cannot use standard package managers (apt, yum, etc.) like we can on an ec2 instance or your local machine</li><li>Binary dependencies must be pre-compiled for Amazon Linux, which I learned the hard way when I first tried to set this up. I remember trying to use Amazon Linux (since it's the default Lambda environment), but ran into a bunch of headaches because it uses yum as its package manager. The biggest pain point? The default Amazon Linux repositories have very limited TeX/LaTeX packages compared to what you get with Ubuntu/Debian repositories.&nbsp;</li><li>Some packages you'd expect to find just aren't there at all, and even when you do find them, they often have different names than what you're used to. For example, what's `texlive-latex-extra` in Ubuntu becomes `texlive-latex` in Amazon Linux - and trust me, that can lead to some confusing moments when you're following tutorials!<br><br>Later in this guide, I'll show you how we can make our lives much easier by using Ubuntu as our base image instead. Sometimes the path of least resistance is the best path forward!</li></ul></li></ol><p>We'll build a Docker image that bundles all the necessary LaTeX dependencies and tooling into a custom runtime environment for our Lambda function.</p><h3>Creating the Docker Image</h3><p><br>The key to successfully deploying a Lambda function with binary dependencies is to create a self-contained, reproducible runtime environment (A docker image). Docker is an excellent tool for this, as it allows us to package our function code, libraries, and system dependencies into a single, portable image.<br><br>Here's a high-level overview of the steps we'll take to create the Docker-based deployment:</p><ul><li><strong>Base Image Selection:</strong> We'll start with an Ubuntu-based image that includes the necessary system packages and tools, such as wget, tar, fontconfig, and the core LaTeX distribution. And we will also define our image in 3 <a href="https://docs.docker.com/build/building/multi-stage/" target="_blank">Stages </a>for our convenience.&nbsp;<br>Set the DEBIAN_FRONTEND variable to noninteractive to bypass prompts that normally require user input during software installation—this is crucial because Docker builds are non-interactive.</li><li><strong>Installing necessary Stuff: </strong>After selecting Ubuntu as our base image we will install necessary things that we need our lambda function to have, in this case latex along with python and other dependencies necessary for installing them. (you can install the packages and libraries according to your needs.)</li><li><strong>Font Installation:</strong> In this specific image i am also installing fonts for latex (Times new roman) you can also install specific fonts for latex if they don't come by default.</li><li><strong>Setting the working directory:</strong>&nbsp;it is important to explicitly set the <strong>working directory</strong> where the function's code and dependencies reside. This is done using the <strong>WORKDIR </strong>instruction in the Dockerfile.</li><li><strong>Copying your code files:</strong>&nbsp; After specifying the working directory you will copy your python script in it. (In this case this script will compile latex)</li><li><strong>Install Pip &amp;&nbsp;awslambdaric:&nbsp;&nbsp;</strong>This step is crucial regardless of the specific use case—whether you're compiling LaTeX, using custom binaries, or building a Lambda function that requires other non-standard system dependencies. When deploying a Docker-based Lambda function, awslambdaric is necessary because the function uses a custom runtime through a container image.<br>Unlike the standard AWS Lambda runtime (used when deploying via a ZIP file or AWS SAM template), a containerized Lambda does not inherently manage the communication with the AWS Lambda Runtime API.<br>In this setup, I am installing the Python version of awslambdaric, but it is worth noting that AWS provides similar libraries for other languages, such as JavaScript, to support custom runtimes for a variety of programming environments.</li><li><strong>Setting the Entry point and executing lambda:&nbsp;</strong>The ENTRYPOINT specifies the command that should run as the primary process when the container starts. In this case, it runs the Python interpreter located in the virtual environment (/venv/bin/python3.11) with the module awslambdaric. awslambdaric acts as the interface between the AWS Lambda service and your function's handler, enabling the container to process Lambda events and return responses.</li></ul><p>By following this approach, we can ensure that our Lambda function has access to all the necessary components to compile LaTeX sources and generate PDFz, without relying on the default Lambda runtime environment.</p><img class="w-100" src="../assets/img/lambda-to-ecr-to-lambda-768x402.webp"><h3 class="mt-4">Building the image and deploying the Lambda Function</h3><p>After writing the image code we have to build it and push the code to aws ECR. After that, we’ll create a Lambda function and set it up to use the ECR repo as the source for the code. Here’s a detailed step-by-step guide with commands.<br><br></p><ul><li><strong>Build and Push the Docker Image:&nbsp;</strong>We'll use Docker to build the Docker image and push it to aws container registry (Amazon Elastic Container Registry (ECR)). Here i am using 'my-latex-lambda' as the image name, you can change it if you want.<div class="TJaHlju0H"><button type="button" value-copy="docker build -t my-latex-lambda ." onclick="copyValueToClipboard(this)"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 16 16" class="bi bi-clipboard">
  <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"></path>
  <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"></path>
</svg></button><div><p>$ docker build -t my-latex-lambda .</p></div></div></li><li><strong>Create ECR Repo in AWS: </strong>The command bellow will output a json after creating the repo, you will need to copy the 'repositoryUri'.<br><div class="TJaHlju0H"><button type="button" value-copy="aws ecr create-repository --repository-name my-repo" onclick="copyValueToClipboard(this)"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 16 16" class="bi bi-clipboard">
  <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"></path>
  <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"></path>
</svg></button><div><p>$ aws ecr create-repository --repository-name my-repo</p></div></div></li><li><strong>Authenticating docker into an ECR Repe: </strong>Now you have to replace the '&lt;uri&gt;' in the command bellow with 'repositoryUri'<br><div class="TJaHlju0H"><button type="button" value-copy="aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin" onclick="copyValueToClipboard(this)"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 16 16" class="bi bi-clipboard">
  <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"></path>
  <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"></path>
</svg></button><div><p>$ aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin&nbsp;</p></div></div></li><li><strong>Tagging the image and pushing to the repo: </strong>Again&nbsp; you have to replace the '&lt;uri&gt;' in the commands bellow with 'repositoryUri'.<strong>&nbsp;</strong>After that, run each command in sequence and it will push the image to the reop.<br><div class="TJaHlju0H"><button type="button" value-copy="docker tag my-latex-lambda:latest <uri>:latest" onclick="copyValueToClipboard(this)"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 16 16" class="bi bi-clipboard">
  <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"></path>
  <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"></path>
</svg></button><div><p>$&nbsp;docker tag my-latex-lambda:latest &lt;uri&gt;:latest</p></div></div><div class="TJaHlju0H"><button type="button" value-copy="docker push <uri>:latest" onclick="copyValueToClipboard(this)"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 16 16" class="bi bi-clipboard">
  <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"></path>
  <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"></path>
</svg></button><div><p>$&nbsp;docker push &lt;uri&gt;:latest</p></div></div></li><li><strong>Create the Lambda Function:</strong> Go to the AWS Lambda console, create a new function, and set it up to use the Docker image we just pushed to ECR. For this example, we’re using Python, but you can pick the runtime that works for your setup.</li></ul><p>By following this deployment process, we can ensure that our LaTeX-powered Lambda function is packaged with all the necessary dependencies, making it easy to deploy and scale as needed. <br><br>Here's a reference implementation of the Docker image we discussed. it provides a solid foundation that you can adapt to your specific needs:</p><div class="dropdownX"><button class="dropdownX-button" type="button" onclick="toggleDropdownX()">Code</button><div id="myDropdown" class="dropdownX-content"><p style="padding: 4px;font-size: 14px !important;line-height: 19px !important;"><span style="color: rgb(124, 166, 104);">#Set the Function directory(working directory) beforehand</span><br><br><span style="color: rgb(197, 134, 192);">ARG</span> <span style="color: rgb(156, 220, 254);">FUNCTION_DIR</span><span style="color: rgb(212, 212, 212);">=</span><span style="color: rgb(206, 145, 120);">"/var/task"</span><br><br><span style="color: rgb(124, 166, 104);"># This is Stage 1</span><br><span style="color: rgb(197, 134, 192);">FROM</span> <span style="color: rgb(78, 201, 176);">ubuntu</span>:<span style="color: rgb(156, 220, 254);">22.04</span> <span style="color: rgb(197, 134, 192);">as</span> <span style="color: rgb(78, 201, 176);">base</span><br><br># Set environment variable to prevent interactive prompts<br><span style="color: rgb(197, 134, 192);">ENV</span> <span style="color: rgb(156, 220, 254);">DEBIAN_FRONTEND</span><span style="color: rgb(212, 212, 212);">=</span><span style="color: rgb(156, 220, 254);">noninteractive</span><br><br>#Install Python and Latex:<br><span style="color: rgb(197, 134, 192);">RUN</span> <span style="color: rgb(156, 220, 254);">apt-get</span> <span style="color: rgb(156, 220, 254);">update</span> <span style="color: rgb(156, 220, 254);">&amp;&amp;</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; &nbsp;<br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">apt-get</span> <span style="color: rgb(156, 220, 254);">install</span> <span style="color: rgb(156, 220, 254);">-y</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; &nbsp; <br><span style="color: rgb(156, 220, 254);">&nbsp; perl</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; &nbsp; <br><span style="color: rgb(156, 220, 254);">&nbsp; wget</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; &nbsp; <br><span style="color: rgb(156, 220, 254);">&nbsp; tar</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; &nbsp;<br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">gzip</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp;<br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">fontconfig</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; <br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">texlive-latex-extra</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; <br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">texlive-xetex</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; <br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">texlive-latex-recommended</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; &nbsp;<br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">python3.11</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; <br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">python3.11-venv</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; <br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">python3.11-distutils</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; <br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">g++</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; &nbsp;<br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">make</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp;<br>&nbsp; &nbsp;<span style="color: rgb(156, 220, 254);">cmake</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; &nbsp;<br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">unzip</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; &nbsp; <br><span style="color: rgb(156, 220, 254);">&nbsp; libcurl4-openssl-dev</span> <span style="color: rgb(156, 220, 254);">&amp;&amp;</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp;<br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">apt-get</span> <span style="color: rgb(156, 220, 254);">clean</span> <span style="color: rgb(156, 220, 254);">&amp;&amp;</span> <span style="color: rgb(220, 220, 170);">\</span>&nbsp; <br>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">rm</span> <span style="color: rgb(156, 220, 254);">-rf</span> <span style="color: rgb(156, 220, 254);">/var/lib/apt/lists/*</span><br><br>#Note: Font installation steps removed for brevity<br><br>#Now caomes the second stage<br><span style="color: rgb(197, 134, 192);">FROM</span> <span style="color: rgb(78, 201, 176);">base</span> <span style="color: rgb(197, 134, 192);">as</span> <span style="color: rgb(78, 201, 176);">pip-install</span><br><br>#Create virtual environtment&nbsp;<br><br><span style="color: rgb(198, 120, 221);">RUN</span> python3.11 -m venv /venv &amp;&amp; <span style="color: rgb(97, 175, 239);">\</span><br>    /venv/bin/pip install awslambdaric<br><br><br><br>#Here we will install awsLambdric which is the most important step<br><span style="color: rgb(197, 134, 192);">RUN</span> <span style="color: rgb(156, 220, 254);">/venv/bin/pip</span> <span style="color: rgb(156, 220, 254);">install</span> <span style="color: rgb(156, 220, 254);">awslambdaric</span><br><br>#And Here is out final stage where we copy all of out code:<br><span style="color: rgb(197, 134, 192);">FROM</span> <span style="color: rgb(78, 201, 176);">base</span><br><br><span style="color: rgb(197, 134, 192);">ARG</span> <span style="color: rgb(156, 220, 254);">FUNCTION_DIR</span><br><br>#Set the directory for our function code:<br><span style="color: rgb(197, 134, 192);">WORKDIR</span> <span style="color: rgb(156, 220, 254);">${FUNCTION_DIR}</span><br><br>#Here we will copy all of our python function code:<br><span style="color: rgb(197, 134, 192);">COPY</span> <span style="color: rgb(156, 220, 254);">lambda_function.py</span> <span style="color: rgb(156, 220, 254);">${FUNCTION_DIR}</span><br><span style="color: rgb(197, 134, 192);">COPY</span> <span style="color: rgb(156, 220, 254);">dependencies.py</span> <span style="color: rgb(156, 220, 254);">${FUNCTION_DIR}</span><br><span style="color: rgb(197, 134, 192);">COPY</span> <span style="color: rgb(156, 220, 254);">requirements.txt</span> <span style="color: rgb(156, 220, 254);">${FUNCTION_DIR}</span><br><br>#Now we will install all the python packages listed in requirements fuile<br><br><span style="color: rgb(197, 134, 192);">RUN</span> <span style="color: rgb(156, 220, 254);">/venv/bin/pip</span> <span style="color: rgb(156, 220, 254);">install</span> <span style="color: rgb(156, 220, 254);">-r</span> <span style="color: rgb(156, 220, 254);">requirements.txt</span><br>#Here we will set the ENTRYPOINT to use awslambdaric<br><br><span style="color: rgb(197, 134, 192);">ENTRYPOINT</span> <span style="color: rgb(156, 220, 254);">[</span> <span style="color: rgb(206, 145, 120);">"/venv/bin/python3.11"</span><span style="color: rgb(156, 220, 254);">,</span> <span style="color: rgb(206, 145, 120);">"-m"</span><span style="color: rgb(156, 220, 254);">,</span> <span style="color: rgb(206, 145, 120);">"awslambdaric"</span><span style="color: rgb(156, 220, 254);">]</span><br><br><span style="color: rgb(197, 134, 192);">CMD</span> <span style="color: rgb(156, 220, 254);">[</span> <span style="color: rgb(206, 145, 120);">"lambda_function.handler"</span> <span style="color: rgb(156, 220, 254);">]</span><br><br></p></div></div><p><br><strong>Conclusion</strong><br><br>Deploying Lambda functions with binary dependencies presents unique challenges, but Docker-based containerization offers an elegant solution. This approach provides several key benefits<br><br><strong>Expanded Capacity</strong>: You can now package up to ~10GB of code and content in your function, eliminating the need to juggle multiple Lambda layers.<br><strong>Simplified Dependencies</strong>: The containerized approach creates a self-contained, reproducible runtime environment that's easier to manage and deploy.<br><strong>Flexibility</strong>: While we've focused on LaTeX in this example, this strategy works equally well for other use cases requiring custom binaries, such as:</p><ul><li><span style="color: rgb(255, 255, 255);">Image processing tools</span></li><li><span style="color: rgb(255, 255, 255);">Video transcoding utilities</span></li><li><span style="color: rgb(255, 255, 255);">File conversion software</span></li><li><span style="color: rgb(255, 255, 255);">Custom compilation tools</span></li></ul><p>However, it's important to note that this approach does come with some trade-offs. Larger container images can increase cold start times and impact function performance. As with any architectural decision, you'll need to balance these factors against your specific requirements.<br>The power of this approach lies in its versatility - once you understand how to containerize one type of binary dependency for Lambda, you can apply the same principles to virtually any other complex runtime requirement. Whether you're generating PDFs with LaTeX, processing images, or transcoding videos, the containerized Lambda pattern provides a robust foundation for your serverless applications.</p></div></div></section><section class="d-xxl-flex align-items-xxl-end"><div class="footer-div"><div class="footer-c"><div class="col-md-4 fc1"><h1 class="time"><i class="fa fa-copyright d-flex align-items-center" style="font-weight: bold;"></i>&nbsp;2024</h1></div><div class="col-md-4 fc2"><h1 class="d-flex d-md-flex justify-content-center justify-content-md-center time">&nbsp;<span class="d-xxl-flex align-items-xxl-center"><i class="fa fa-circle HGLXXcqi"></i>&nbsp;</span> LAHORE&nbsp;<span id="time"></span>&nbsp;</h1></div><div class="col-md-4 fc3"><a href=""><h1 class="d-lg-flex justify-content-lg-end time">BACKTOTOP</h1></a></div></div></div></section><div class="offcanvas offcanvas-end" tabindex="-1" id="offcanvas"><div class="offcanvas-body"><div id="of-cnvs-cls-btn-div-1"><button class="btn btn-primary" id="cls-btn-1" type="button" data-bs-dismiss="offcanvas"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none">
  <path d="M6.2253 4.81108C5.83477 4.42056 5.20161 4.42056 4.81108 4.81108C4.42056 5.20161 4.42056 5.83477 4.81108 6.2253L10.5858 12L4.81114 17.7747C4.42062 18.1652 4.42062 18.7984 4.81114 19.1889C5.20167 19.5794 5.83483 19.5794 6.22535 19.1889L12 13.4142L17.7747 19.1889C18.1652 19.5794 18.7984 19.5794 19.1889 19.1889C19.5794 18.7984 19.5794 18.1652 19.1889 17.7747L13.4142 12L19.189 6.2253C19.5795 5.83477 19.5795 5.20161 19.189 4.81108C18.7985 4.42056 18.1653 4.42056 17.7748 4.81108L12 10.5858L6.2253 4.81108Z" fill="currentColor"></path>
</svg></button></div><div class="hd53gubdWW345HU8ND66g66"><div class="container"><a role="button" href="../index.html">HOME</a></div><div class="container"><a role="button" href="about.html">ABOUT</a></div><div class="container"><a role="button" href="live.html">LIVE</a></div><div class="container"><a role="button" href="thoughts.html">THOUGHTS</a></div><div class="container"><a role="button" href="https://github.com/HuzaifaYasin910/" target="_blank">GITHUB</a></div><div class="container"><a role="button" href="https://www.linkedin.com/in/huzaifa-yasin-328b01287/" target="_blank">LINKEDIN</a></div><div class="container"><a role="button" href="https://www.instagram.com/huzaifayasin910/" target="_blank">INSTAGRAM</a></div></div></div></div><div id="L7to8g8A5kdeeSv" class="p-3 WM6JbQUsAjg"><h4>Cookies</h4><p>This website uses cookies. Cookies are small text files stored on your device&nbsp;that allow us to analyze site traffic and in some cases-monitor user activity. Without cookies, certain features of the website may not function correctly.</p><button id="L7to8g8A5kdeeSvb" type="button">I understand</button></div><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/baguettebox.js/1.10.0/baguetteBox.min.js"></script><script src="../assets/js/script.min.js"></script></body></html>